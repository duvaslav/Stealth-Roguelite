<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stealth Roguelite</title>
  <style>
    :root {
      --bg: #070b12;
      --panel: #101722;
      --text: #d5ecff;
      --muted: #7f9ab8;
      --accent: #4ed0ff;
      --danger: #ff5f78;
      --warn: #ffcb66;
      --ok: #57f09a;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background:
        radial-gradient(circle at 20% 10%, #152233 0%, transparent 45%),
        radial-gradient(circle at 80% 90%, #11202e 0%, transparent 40%),
        var(--bg);
      color: var(--text);
      font-family: "Courier New", Courier, monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 12px;
    }

    .app {
      width: min(1120px, 100%);
      border: 1px solid #263448;
      background: color-mix(in srgb, var(--bg), #000 24%);
      box-shadow: 0 0 0 1px #0d1520 inset, 0 0 42px #00b5ff20;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      padding: 10px;
    }

    .status-bar,
    .terminal-log,
    .sidebar,
    .grid-wrap {
      border: 1px solid #1d2b40;
      background: color-mix(in srgb, var(--panel), #000 12%);
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      padding: 8px 12px;
      font-size: 14px;
      letter-spacing: 0.02em;
    }

    .main {
      display: grid;
      grid-template-columns: 1fr 260px;
      gap: 10px;
    }

    .grid-wrap {
      overflow: auto;
      padding: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(24, 1.65rem);
      grid-template-rows: repeat(16, 1.65rem);
      gap: 2px;
      user-select: none;
    }

    .cell {
      width: 1.65rem;
      height: 1.65rem;
      display: grid;
      place-items: center;
      border: 1px solid #1a2a3e;
      color: var(--text);
      font-size: 0.92rem;
      line-height: 1;
      transition: color 120ms ease, background 120ms ease;
    }

    .tile-floor { background: #0f1a28; }
    .tile-wall { background: #1a2230; color: #6e7f92; }
    .tile-player { background: #1c2f3f; color: var(--accent); font-weight: bold; }
    .tile-enemy { background: #2b1b24; color: var(--danger); font-weight: bold; }
    .tile-exit { background: #1b2f22; color: var(--ok); font-weight: bold; }

    .sidebar {
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 14px;
    }

    .sidebar h2 {
      margin: 0 0 6px;
      font-size: 14px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .sidebar .stat {
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      border-bottom: 1px dashed #203149;
      padding-bottom: 4px;
    }

    .terminal-log {
      min-height: 140px;
      max-height: 200px;
      overflow: auto;
      padding: 8px 12px;
      font-size: 13px;
      line-height: 1.4;
    }

    .terminal-log p {
      margin: 0 0 4px;
      color: var(--muted);
    }

    .terminal-log p.ok { color: var(--ok); }
    .terminal-log p.warn { color: var(--warn); }
    .terminal-log p.danger { color: var(--danger); }

    .menu-overlay {
      position: fixed;
      inset: 0;
      background: #02070fd8;
      display: grid;
      place-items: center;
      z-index: 10;
    }

    .menu {
      width: min(420px, calc(100% - 24px));
      border: 1px solid #2f425f;
      background: color-mix(in srgb, var(--panel), #000 18%);
      box-shadow: 0 0 26px #00afff22;
      padding: 14px;
    }

    .menu h1 {
      margin: 0 0 10px;
      font-size: 18px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .menu button {
      width: 100%;
      border: 1px solid #35557e;
      background: #0e1725;
      color: var(--text);
      font: inherit;
      padding: 10px;
      margin: 5px 0;
      text-align: left;
      cursor: pointer;
    }

    .menu button:hover,
    .menu button:focus-visible {
      outline: none;
      border-color: var(--accent);
      color: var(--accent);
      background: #112236;
    }

    @media (max-width: 900px) {
      .main { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="status-bar" aria-label="Status bar">
      <div id="status-left">HP: 10 | Noise: 0 | Turn: 1</div>
      <div id="status-right">Mode: Menu</div>
    </header>

    <main class="main" aria-label="Grid and sidebar">
      <section class="grid-wrap">
        <div id="grid" class="grid" aria-label="Game grid"></div>
      </section>

      <aside class="sidebar" aria-label="Sidebar">
        <h2>Run Data</h2>
        <div class="stat"><span>Seed</span><span id="seed-value">—</span></div>
        <div class="stat"><span>Daily</span><span id="daily-value">No</span></div>
        <div class="stat"><span>Objectives</span><span>Reach EXIT</span></div>
        <div class="stat"><span>Build</span><span>Prototype</span></div>
      </aside>
    </main>

    <section class="terminal-log" id="terminal" aria-label="Terminal log"></section>
  </div>

  <div class="menu-overlay" id="menu-overlay">
    <div class="menu">
      <h1>Stealth Roguelite</h1>
      <button data-action="new-random">New Run (random)</button>
      <button data-action="daily">Daily Run</button>
      <button data-action="continue">Continue</button>
      <button data-action="help">How to play</button>
      <button data-action="settings">Settings</button>
    </div>
  </div>

  <script>
    const gameState = {
      width: 24,
      height: 16,
      turn: 1,
      mode: 'menu',
      hp: 10,
      noise: 0,
      daily: false,
      seed: null,
      tiles: [],
      entities: {
        player: { x: 1, y: 1, glyph: '@' },
        enemy: { x: 11, y: 8, glyph: 'E' },
        exit: { x: 22, y: 14, glyph: 'X' }
      },
      dom: {
        grid: document.getElementById('grid'),
        terminal: document.getElementById('terminal'),
        statusLeft: document.getElementById('status-left'),
        statusRight: document.getElementById('status-right'),
        seed: document.getElementById('seed-value'),
        daily: document.getElementById('daily-value'),
        menu: document.getElementById('menu-overlay')
      },
      cellEls: [],

      rng: {
        xmur3(seedStr) {
          let h = 1779033703 ^ seedStr.length;
          for (let i = 0; i < seedStr.length; i++) {
            h = Math.imul(h ^ seedStr.charCodeAt(i), 3432918353);
            h = (h << 13) | (h >>> 19);
          }
          return () => {
            h = Math.imul(h ^ (h >>> 16), 2246822507);
            h = Math.imul(h ^ (h >>> 13), 3266489909);
            return (h ^= h >>> 16) >>> 0;
          };
        },
        mulberry32(a) {
          return () => {
            let t = (a += 0x6D2B79F5);
            t = Math.imul(t ^ (t >>> 15), t | 1);
            t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
          };
        },
        create(seedValue) {
          const seedFn = this.xmur3(String(seedValue));
          return this.mulberry32(seedFn());
        }
      },

      gen: {
        map(state, random) {
          const tiles = Array.from({ length: state.width * state.height }, () => 'floor');
          for (let y = 0; y < state.height; y++) {
            for (let x = 0; x < state.width; x++) {
              const i = y * state.width + x;
              const isBorder = x === 0 || y === 0 || x === state.width - 1 || y === state.height - 1;
              if (isBorder || random() < 0.08) tiles[i] = 'wall';
            }
          }
          tiles[state.entities.player.y * state.width + state.entities.player.x] = 'floor';
          tiles[state.entities.enemy.y * state.width + state.entities.enemy.x] = 'floor';
          tiles[state.entities.exit.y * state.width + state.entities.exit.x] = 'floor';
          state.tiles = tiles;
        }
      },

      fov: {
        isVisible() {
          return true;
        }
      },

      ai: {
        stepEnemy(state) {
          if (state.mode !== 'running') return;
          const dx = Math.sign(state.entities.player.x - state.entities.enemy.x);
          const dy = Math.sign(state.entities.player.y - state.entities.enemy.y);
          state.entities.enemy.x += dx;
          state.entities.enemy.y += dy;
        }
      },

      rules: {
        canMove(state, x, y) {
          if (x < 0 || y < 0 || x >= state.width || y >= state.height) return false;
          return state.tiles[y * state.width + x] !== 'wall';
        },
        tick(state) {
          state.turn += 1;
          state.ai.stepEnemy(state);
        }
      },

      render: {
        createGridOnce(state) {
          if (state.cellEls.length) return;
          const frag = document.createDocumentFragment();
          for (let i = 0; i < state.width * state.height; i++) {
            const el = document.createElement('div');
            el.className = 'cell';
            el.textContent = ' ';
            state.cellEls.push(el);
            frag.appendChild(el);
          }
          state.dom.grid.appendChild(frag);
        },
        frame(state) {
          for (let y = 0; y < state.height; y++) {
            for (let x = 0; x < state.width; x++) {
              const i = y * state.width + x;
              const cell = state.cellEls[i];
              const tile = state.tiles[i];
              cell.className = `cell tile-${tile}`;
              cell.textContent = '.';
            }
          }

          const drawEntity = (entity, cssClass) => {
            const i = entity.y * state.width + entity.x;
            const cell = state.cellEls[i];
            if (!cell || !state.fov.isVisible(entity.x, entity.y)) return;
            cell.className = `cell ${cssClass}`;
            cell.textContent = entity.glyph;
          };

          drawEntity(state.entities.player, 'tile-player');
          drawEntity(state.entities.enemy, 'tile-enemy');
          drawEntity(state.entities.exit, 'tile-exit');

          state.dom.statusLeft.textContent = `HP: ${state.hp} | Noise: ${state.noise} | Turn: ${state.turn}`;
          state.dom.statusRight.textContent = `Mode: ${state.mode}`;
          state.dom.seed.textContent = String(state.seed ?? '—');
          state.dom.daily.textContent = state.daily ? 'Yes' : 'No';
        },
        log(state, message, tone = 'ok') {
          const p = document.createElement('p');
          p.className = tone;
          p.textContent = `> ${message}`;
          state.dom.terminal.appendChild(p);
          state.dom.terminal.scrollTop = state.dom.terminal.scrollHeight;
        }
      },

      storage: {
        key: 'stealth-roguelite-save-v1',
        save(state) {
          const payload = {
            turn: state.turn,
            hp: state.hp,
            noise: state.noise,
            mode: state.mode,
            daily: state.daily,
            seed: state.seed,
            tiles: state.tiles,
            entities: state.entities
          };
          localStorage.setItem(this.key, JSON.stringify(payload));
        },
        load() {
          const raw = localStorage.getItem(this.key);
          return raw ? JSON.parse(raw) : null;
        }
      }
    };

    function initializeRun(type) {
      const today = new Date().toISOString().slice(0, 10);
      const seed = type === 'daily' ? `daily-${today}` : `run-${Date.now()}`;
      const random = gameState.rng.create(seed);

      gameState.turn = 1;
      gameState.mode = 'running';
      gameState.daily = type === 'daily';
      gameState.seed = seed;
      gameState.entities.player = { x: 1, y: 1, glyph: '@' };
      gameState.entities.enemy = { x: 11, y: 8, glyph: 'E' };
      gameState.entities.exit = { x: 22, y: 14, glyph: 'X' };

      gameState.gen.map(gameState, random);
      gameState.render.frame(gameState);
      gameState.storage.save(gameState);
      gameState.render.log(gameState, `Run initialized with seed ${seed}`);
      gameState.dom.menu.style.display = 'none';
    }

    function continueRun() {
      const data = gameState.storage.load();
      if (!data) {
        gameState.render.log(gameState, 'No save found. Starting random run instead.', 'warn');
        initializeRun('random');
        return;
      }
      Object.assign(gameState, data);
      gameState.mode = 'running';
      gameState.render.frame(gameState);
      gameState.render.log(gameState, 'Continue successful. Save restored.');
      gameState.dom.menu.style.display = 'none';
    }

    gameState.render.createGridOnce(gameState);
    gameState.render.frame(gameState);
    gameState.render.log(gameState, 'Boot sequence complete. Choose startup option.');

    document.querySelector('.menu').addEventListener('click', (event) => {
      const btn = event.target.closest('button[data-action]');
      if (!btn) return;
      const action = btn.dataset.action;

      if (action === 'new-random') initializeRun('random');
      if (action === 'daily') initializeRun('daily');
      if (action === 'continue') continueRun();
      if (action === 'help') gameState.render.log(gameState, 'How to play: Move silently, avoid E, reach X.', 'warn');
      if (action === 'settings') gameState.render.log(gameState, 'Settings are not implemented in this prototype.', 'danger');
    });

    window.addEventListener('keydown', (event) => {
      if (gameState.mode !== 'running') return;
      const moves = {
        ArrowUp: [0, -1],
        ArrowDown: [0, 1],
        ArrowLeft: [-1, 0],
        ArrowRight: [1, 0]
      };
      const dir = moves[event.key];
      if (!dir) return;

      event.preventDefault();
      const [dx, dy] = dir;
      const targetX = gameState.entities.player.x + dx;
      const targetY = gameState.entities.player.y + dy;

      if (gameState.rules.canMove(gameState, targetX, targetY)) {
        gameState.entities.player.x = targetX;
        gameState.entities.player.y = targetY;
        gameState.rules.tick(gameState);
        gameState.render.frame(gameState);
        gameState.storage.save(gameState);

        if (targetX === gameState.entities.exit.x && targetY === gameState.entities.exit.y) {
          gameState.mode = 'menu';
          gameState.render.frame(gameState);
          gameState.dom.menu.style.display = 'grid';
          gameState.render.log(gameState, 'Extraction complete. Mission success.', 'ok');
        }
      }
    });
  </script>
</body>
</html>
