<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stealth Roguelite</title>
  <style>
    :root {
      --bg: #070b12;
      --panel: #101722;
      --text: #d5ecff;
      --muted: #7f9ab8;
      --accent: #4ed0ff;
      --danger: #ff5f78;
      --warn: #ffcb66;
      --ok: #57f09a;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background:
        radial-gradient(circle at 20% 10%, #152233 0%, transparent 45%),
        radial-gradient(circle at 80% 90%, #11202e 0%, transparent 40%),
        var(--bg);
      color: var(--text);
      font-family: "Courier New", Courier, monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 12px;
    }

    .app {
      width: min(1120px, 100%);
      border: 1px solid #263448;
      background: color-mix(in srgb, var(--bg), #000 24%);
      box-shadow: 0 0 0 1px #0d1520 inset, 0 0 42px #00b5ff20;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      padding: 10px;
    }

    .status-bar,
    .terminal-log,
    .sidebar,
    .grid-wrap {
      border: 1px solid #1d2b40;
      background: color-mix(in srgb, var(--panel), #000 12%);
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      padding: 8px 12px;
      font-size: 14px;
      letter-spacing: 0.02em;
    }

    .main {
      display: grid;
      grid-template-columns: 1fr 260px;
      gap: 10px;
    }

    .grid-wrap {
      overflow: auto;
      padding: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(24, 1.65rem);
      grid-template-rows: repeat(16, 1.65rem);
      gap: 2px;
      user-select: none;
    }

    .cell {
      width: 1.65rem;
      height: 1.65rem;
      display: grid;
      place-items: center;
      border: 1px solid #1a2a3e;
      color: var(--text);
      font-size: 0.92rem;
      line-height: 1;
      transition: color 120ms ease, background 120ms ease;
    }

    .tile-floor { background: #0f1a28; }
    .tile-wall { background: #1a2230; color: #6e7f92; }
    .tile-player { background: #1c2f3f; color: var(--accent); font-weight: bold; }
    .tile-enemy { background: #2b1b24; color: var(--danger); font-weight: bold; }
    .tile-exit { background: #1b2f22; color: var(--ok); font-weight: bold; }

    .sidebar {
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 14px;
    }

    .sidebar h2 {
      margin: 0 0 6px;
      font-size: 14px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .sidebar .stat {
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      border-bottom: 1px dashed #203149;
      padding-bottom: 4px;
    }

    .sidebar .seed-actions {
      margin-top: 6px;
    }

    .sidebar .seed-actions button {
      width: 100%;
      border: 1px solid #35557e;
      background: #0e1725;
      color: var(--text);
      font: inherit;
      padding: 6px 8px;
      cursor: pointer;
    }

    .sidebar .seed-actions button:hover,
    .sidebar .seed-actions button:focus-visible {
      outline: none;
      border-color: var(--accent);
      color: var(--accent);
      background: #112236;
    }

    .terminal-log {
      min-height: 140px;
      max-height: 200px;
      overflow: auto;
      padding: 8px 12px;
      font-size: 13px;
      line-height: 1.4;
    }

    .terminal-log p {
      margin: 0 0 4px;
      color: var(--muted);
    }

    .terminal-log p.ok { color: var(--ok); }
    .terminal-log p.warn { color: var(--warn); }
    .terminal-log p.danger { color: var(--danger); }

    .menu-overlay {
      position: fixed;
      inset: 0;
      background: #02070fd8;
      display: grid;
      place-items: center;
      z-index: 10;
    }

    .menu {
      width: min(420px, calc(100% - 24px));
      border: 1px solid #2f425f;
      background: color-mix(in srgb, var(--panel), #000 18%);
      box-shadow: 0 0 26px #00afff22;
      padding: 14px;
    }

    .menu h1 {
      margin: 0 0 10px;
      font-size: 18px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .menu button {
      width: 100%;
      border: 1px solid #35557e;
      background: #0e1725;
      color: var(--text);
      font: inherit;
      padding: 10px;
      margin: 5px 0;
      text-align: left;
      cursor: pointer;
    }

    .menu button:hover,
    .menu button:focus-visible {
      outline: none;
      border-color: var(--accent);
      color: var(--accent);
      background: #112236;
    }

    @media (max-width: 900px) {
      .main { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="status-bar" aria-label="Status bar">
      <div id="status-left">HP: 10 | Noise: 0 | Turn: 1</div>
      <div id="status-right">Mode: Menu</div>
    </header>

    <main class="main" aria-label="Grid and sidebar">
      <section class="grid-wrap">
        <div id="grid" class="grid" aria-label="Game grid"></div>
      </section>

      <aside class="sidebar" aria-label="Sidebar">
        <h2>Run Data</h2>
        <div class="stat"><span>Seed</span><span id="seed-value">—</span></div>
        <div class="stat"><span>Daily</span><span id="daily-value">No</span></div>
        <div class="stat"><span>Objectives</span><span>Reach EXIT</span></div>
        <div class="stat"><span>Build</span><span>Prototype</span></div>
        <div class="seed-actions"><button id="copy-seed" type="button">Copy seed</button></div>
      </aside>
    </main>

    <section class="terminal-log" id="terminal" aria-label="Terminal log"></section>
  </div>

  <div class="menu-overlay" id="menu-overlay">
    <div class="menu">
      <h1>Stealth Roguelite</h1>
      <button data-action="new-random">New Run (random)</button>
      <button data-action="daily">Daily Run</button>
      <button data-action="continue">Continue</button>
      <button data-action="help">How to play</button>
      <button data-action="settings">Settings</button>
    </div>
  </div>

  <script>
    const TILE_GLYPH = {
      floor: '.',
      wall: '#',
      door: '+',
      terminal: 'T',
      exit: 'X',
      extraction: 'E',
      core: 'C'
    };

    const LEVEL_OBJECTIVES = [
      'Reach exit node',
      'Reach exit node',
      'Reach exit node',
      'Reach exit node',
      'Download CORE (5 turns) then EXTRACT'
    ];

    const gameState = {
      width: 24,
      height: 16,
      turn: 1,
      mode: 'menu',
      hp: 10,
      noise: 0,
      alertLevel: 0,
      exposure: 0,
      daily: false,
      seed: null,
      floor: 1,
      tiles: [],
      memory: [],
      visible: [],
      downloadProgress: 0,
      downloadNeeded: 5,
      random: Math.random,
      entities: {
        player: { x: 1, y: 1, glyph: '@', emp: 0 },
        guards: [],
        cameras: [],
        items: []
      },
      dom: {
        grid: document.getElementById('grid'),
        terminal: document.getElementById('terminal'),
        statusLeft: document.getElementById('status-left'),
        statusRight: document.getElementById('status-right'),
        seed: document.getElementById('seed-value'),
        daily: document.getElementById('daily-value'),
        menu: document.getElementById('menu-overlay'),
        objective: document.querySelector('.stat:nth-of-type(3) span:last-child'),
        copySeed: document.getElementById('copy-seed')
      },
      cellEls: [],

      rng: {
        hashString(seedStr) {
          let h = 2166136261;
          for (let i = 0; i < seedStr.length; i++) {
            h ^= seedStr.charCodeAt(i);
            h = Math.imul(h, 16777619);
          }
          return h >>> 0;
        },
        mulberry32(a) {
          return () => {
            let t = (a += 0x6D2B79F5);
            t = Math.imul(t ^ (t >>> 15), t | 1);
            t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
          };
        },
        create(seedValue) {
          const seedInt = this.hashString(String(seedValue));
          return this.mulberry32(seedInt || 1);
        }
      },

      utils: {
        idx(state, x, y) { return y * state.width + x; },
        inBounds(state, x, y) { return x >= 0 && y >= 0 && x < state.width && y < state.height; },
        manhattan(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); },
        isWalkableTile(tile) {
          return tile !== 'wall' && tile !== 'door';
        },
        bfsDistance(state, start, targets) {
          const queue = [{ x: start.x, y: start.y, dist: 0 }];
          const seen = new Set([`${start.x},${start.y}`]);
          const wanted = new Set(targets.map((t) => `${t.x},${t.y}`));
          while (queue.length) {
            const node = queue.shift();
            if (wanted.has(`${node.x},${node.y}`)) return node.dist;
            for (const [dx, dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
              const nx = node.x + dx;
              const ny = node.y + dy;
              if (!this.inBounds(state, nx, ny)) continue;
              const key = `${nx},${ny}`;
              if (seen.has(key)) continue;
              const tile = state.tiles[this.idx(state, nx, ny)];
              if (!this.isWalkableTile(tile)) continue;
              seen.add(key);
              queue.push({ x: nx, y: ny, dist: node.dist + 1 });
            }
          }
          return Infinity;
        },
        randomFloor(state, allowedTiles = ['floor']) {
          for (let tries = 0; tries < 2000; tries++) {
            const x = 1 + Math.floor(state.random() * (state.width - 2));
            const y = 1 + Math.floor(state.random() * (state.height - 2));
            const tile = state.tiles[this.idx(state, x, y)];
            const occupied = this.getEntityAt(state, x, y);
            if (allowedTiles.includes(tile) && !occupied) return { x, y };
          }
          throw new Error('Failed to find random floor tile');
        },
        getEntityAt(state, x, y) {
          if (state.entities.player.x === x && state.entities.player.y === y) return state.entities.player;
          for (const guard of state.entities.guards) if (guard.x === x && guard.y === y) return guard;
          for (const cam of state.entities.cameras) if (cam.x === x && cam.y === y) return cam;
          for (const item of state.entities.items) if (item.x === x && item.y === y && !item.used) return item;
          return null;
        },
        los(state, x0, y0, x1, y1) {
          let x = x0;
          let y = y0;
          const dx = Math.abs(x1 - x0);
          const dy = Math.abs(y1 - y0);
          const sx = x0 < x1 ? 1 : -1;
          const sy = y0 < y1 ? 1 : -1;
          let err = dx - dy;

          while (!(x === x1 && y === y1)) {
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x += sx; }
            if (e2 < dx) { err += dx; y += sy; }
            if (x === x1 && y === y1) return true;
            const t = state.tiles[this.idx(state, x, y)];
            if (t === 'wall' || t === 'door') return false;
          }
          return true;
        }
      },

      gen: {
        carveRoom(state, tiles, room) {
          for (let y = room.y; y < room.y + room.h; y++) {
            for (let x = room.x; x < room.x + room.w; x++) {
              tiles[y * state.width + x] = 'floor';
            }
          }
        },
        carveLCorridor(state, tiles, a, b) {
          const horizontalFirst = state.random() < 0.5;
          const carveLine = (x0, y0, x1, y1) => {
            let x = x0;
            let y = y0;
            while (x !== x1 || y !== y1) {
              tiles[y * state.width + x] = 'floor';
              if (x !== x1) x += x < x1 ? 1 : -1;
              else if (y !== y1) y += y < y1 ? 1 : -1;
            }
            tiles[y1 * state.width + x1] = 'floor';
          };
          if (horizontalFirst) {
            carveLine(a.x, a.y, b.x, a.y);
            carveLine(b.x, a.y, b.x, b.y);
          } else {
            carveLine(a.x, a.y, a.x, b.y);
            carveLine(a.x, b.y, b.x, b.y);
          }
        },
        surroundFloorsWithWalls(state, tiles) {
          for (let y = 1; y < state.height - 1; y++) {
            for (let x = 1; x < state.width - 1; x++) {
              const i = y * state.width + x;
              if (tiles[i] !== 'void') continue;
              let nearFloor = false;
              for (let yy = -1; yy <= 1; yy++) {
                for (let xx = -1; xx <= 1; xx++) {
                  if (xx === 0 && yy === 0) continue;
                  if (tiles[(y + yy) * state.width + (x + xx)] === 'floor') nearFloor = true;
                }
              }
              if (nearFloor) tiles[i] = 'wall';
            }
          }
          for (let i = 0; i < tiles.length; i++) {
            if (tiles[i] === 'void') tiles[i] = 'wall';
          }
        },
        roomsConnected(state, tiles, rooms) {
          if (!rooms.length) return false;
          const start = rooms[0].center;
          const queue = [start];
          const seen = new Set([`${start.x},${start.y}`]);
          while (queue.length) {
            const cur = queue.shift();
            for (const [dx, dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
              const nx = cur.x + dx;
              const ny = cur.y + dy;
              if (!state.utils.inBounds(state, nx, ny)) continue;
              const key = `${nx},${ny}`;
              if (seen.has(key)) continue;
              const t = tiles[ny * state.width + nx];
              if (t !== 'floor') continue;
              seen.add(key);
              queue.push({ x: nx, y: ny });
            }
          }
          return rooms.every((room) => seen.has(`${room.center.x},${room.center.y}`));
        },
        map(state) {
          for (let attempt = 0; attempt < 60; attempt++) {
            const tiles = Array.from({ length: state.width * state.height }, () => 'void');
            const rooms = [];
            const roomCount = 6 + Math.floor(state.random() * 5);

            for (let i = 0; i < roomCount * 3 && rooms.length < roomCount; i++) {
              const w = 3 + Math.floor(state.random() * 5);
              const h = 3 + Math.floor(state.random() * 4);
              const x = 1 + Math.floor(state.random() * (state.width - w - 2));
              const y = 1 + Math.floor(state.random() * (state.height - h - 2));
              const candidate = { x, y, w, h, center: { x: x + Math.floor(w / 2), y: y + Math.floor(h / 2) } };
              const overlaps = rooms.some((room) =>
                candidate.x < room.x + room.w + 1 &&
                candidate.x + candidate.w + 1 > room.x &&
                candidate.y < room.y + room.h + 1 &&
                candidate.y + candidate.h + 1 > room.y);
              if (overlaps) continue;
              this.carveRoom(state, tiles, candidate);
              if (rooms.length > 0) {
                this.carveLCorridor(state, tiles, rooms[rooms.length - 1].center, candidate.center);
              }
              rooms.push(candidate);
            }

            if (rooms.length < 6) continue;
            this.surroundFloorsWithWalls(state, tiles);

            if (!this.roomsConnected(state, tiles, rooms)) continue;

            state.tiles = tiles;
            state.generatedRooms = rooms;
            state.memory = Array(tiles.length).fill(false);
            state.visible = Array(tiles.length).fill(false);
            return;
          }
          throw new Error('Map generation failed to build connected rooms');
        },
        ensureReachability(state, origin, targetTileNames) {
          const targets = [];
          for (let y = 0; y < state.height; y++) {
            for (let x = 0; x < state.width; x++) {
              const tile = state.tiles[state.utils.idx(state, x, y)];
              if (targetTileNames.includes(tile)) targets.push({ x, y });
            }
          }
          return state.utils.bfsDistance(state, origin, targets) !== Infinity;
        },
        populate(state) {
          state.entities.guards = [];
          state.entities.cameras = [];
          state.entities.items = [];

          const roomCenters = state.generatedRooms.map((r) => ({ ...r.center }));
          const spawn = roomCenters.shift();
          state.entities.player = { ...spawn, glyph: '@', emp: state.entities.player.emp || 0 };

          const endpoint = roomCenters.pop() || state.utils.randomFloor(state);
          const objectiveTile = state.floor === 5 ? 'core' : 'exit';
          state.tiles[state.utils.idx(state, endpoint.x, endpoint.y)] = objectiveTile;

          if (state.floor === 5) {
            const extraction = roomCenters.pop() || state.utils.randomFloor(state);
            state.tiles[state.utils.idx(state, extraction.x, extraction.y)] = 'extraction';
          }

          const terminalCount = Math.max(1, 1 + Math.floor(state.random() * 2));
          for (let i = 0; i < terminalCount; i++) {
            const terminal = state.utils.randomFloor(state);
            state.tiles[state.utils.idx(state, terminal.x, terminal.y)] = 'terminal';
          }

          const pickupCount = 1 + Math.floor(state.random() * 3);
          for (let i = 0; i < pickupCount; i++) {
            const pos = state.utils.randomFloor(state);
            state.entities.items.push({ ...pos, glyph: i === 0 ? '⚡' : '•', type: i === 0 ? 'emp' : 'scrap', used: false });
          }

          let doorCount = 0;
          for (let y = 1; y < state.height - 1; y++) {
            for (let x = 1; x < state.width - 1; x++) {
              const i = state.utils.idx(state, x, y);
              if (state.tiles[i] !== 'floor') continue;
              const left = state.tiles[state.utils.idx(state, x - 1, y)];
              const right = state.tiles[state.utils.idx(state, x + 1, y)];
              const up = state.tiles[state.utils.idx(state, x, y - 1)];
              const down = state.tiles[state.utils.idx(state, x, y + 1)];
              const horizontalGate = left === 'wall' && right === 'wall' && up === 'floor' && down === 'floor';
              const verticalGate = up === 'wall' && down === 'wall' && left === 'floor' && right === 'floor';
              if ((horizontalGate || verticalGate) && state.random() < 0.2) {
                state.tiles[i] = 'door';
                doorCount += 1;
              }
            }
          }
          for (let i = 0; i < 20 && doorCount < 2; i++) {
            const p = state.utils.randomFloor(state);
            state.tiles[state.utils.idx(state, p.x, p.y)] = 'door';
            doorCount += 1;
          }

          const guardCount = Math.min(7, 1 + state.floor + Math.floor(state.floor / 2));
          const camCount = Math.min(5, Math.floor((state.floor + 1) / 2));
          for (let i = 0; i < guardCount; i++) {
            const pos = state.utils.randomFloor(state);
            state.entities.guards.push({ ...pos, glyph: 'G', state: 'patrol', hearing: 3 + state.floor, vision: 6 + Math.floor(state.floor / 2), target: null, searchTurns: 0 });
          }
          for (let i = 0; i < camCount; i++) {
            const pos = state.utils.randomFloor(state);
            state.entities.cameras.push({ ...pos, glyph: 'C', type: i % 2 ? 'fixed' : 'rotating', angle: Math.floor(state.random() * 4), range: 5 + Math.floor(state.floor / 2), disabled: 0 });
          }

          const goalTiles = state.floor === 5 ? ['core'] : ['exit'];
          if (!this.ensureReachability(state, state.entities.player, goalTiles)) {
            throw new Error('Player cannot reach level objective');
          }
          if (state.floor === 5 && !this.ensureReachability(state, state.entities.player, ['extraction'])) {
            throw new Error('Player cannot reach extraction');
          }
        }
      },

      fov: {
        recalc(state) {
          state.visible.fill(false);
          const r = 8;
          const p = state.entities.player;
          for (let y = p.y - r; y <= p.y + r; y++) {
            for (let x = p.x - r; x <= p.x + r; x++) {
              if (!state.utils.inBounds(state, x, y)) continue;
              const d = Math.abs(x - p.x) + Math.abs(y - p.y);
              if (d > r) continue;
              if (state.utils.los(state, p.x, p.y, x, y)) {
                const i = state.utils.idx(state, x, y);
                state.visible[i] = true;
                state.memory[i] = true;
              }
            }
          }
        }
      },

      detection: {
        update(state) {
          const p = state.entities.player;
          let seen = false;
          for (const g of state.entities.guards) {
            if (state.utils.manhattan(g, p) <= g.vision && state.utils.los(state, g.x, g.y, p.x, p.y)) seen = true;
          }
          for (const c of state.entities.cameras) {
            if (c.disabled > 0) continue;
            if (state.utils.manhattan(c, p) <= c.range && state.utils.los(state, c.x, c.y, p.x, p.y)) seen = true;
          }

          if (seen) {
            state.exposure = Math.min(3, state.exposure + 1);
            state.alertLevel = Math.min(100, state.alertLevel + 8 + state.exposure * 4);
          } else {
            state.exposure = Math.max(0, state.exposure - 1);
            state.alertLevel = Math.max(0, state.alertLevel - 5);
          }
        }
      },

      ai: {
        stepToward(state, actor, tx, ty) {
          const opts = [[1,0],[-1,0],[0,1],[0,-1]].map(([dx,dy]) => ({ x: actor.x + dx, y: actor.y + dy }))
            .filter(p => state.rules.canMove(state, p.x, p.y));
          opts.sort((a,b)=> (Math.abs(a.x-tx)+Math.abs(a.y-ty)) - (Math.abs(b.x-tx)+Math.abs(b.y-ty)));
          if (opts[0]) { actor.x = opts[0].x; actor.y = opts[0].y; }
        },
        stepGuards(state) {
          const p = state.entities.player;
          for (const g of state.entities.guards) {
            const dist = state.utils.manhattan(g, p);
            const sees = dist <= g.vision && state.utils.los(state, g.x, g.y, p.x, p.y);
            const hears = dist <= g.hearing && state.noise > 0;

            if (sees || state.alertLevel >= 70) {
              g.state = 'alert';
              g.target = { x: p.x, y: p.y };
            } else if (hears) {
              g.state = 'investigate';
              g.target = { x: p.x, y: p.y };
            } else if (g.state === 'investigate' && g.target && g.x === g.target.x && g.y === g.target.y) {
              g.state = 'search';
              g.searchTurns = 3;
            } else if (g.state === 'search') {
              g.searchTurns -= 1;
              if (g.searchTurns <= 0) {
                g.state = 'patrol';
                g.target = state.utils.randomFloor(state);
              }
            } else if (!g.target || (g.x === g.target.x && g.y === g.target.y)) {
              g.state = 'patrol';
              g.target = state.utils.randomFloor(state);
            }

            if (g.target) this.stepToward(state, g, g.target.x, g.target.y);
            if (g.x === p.x && g.y === p.y) {
              state.hp -= 1;
              state.render.log(state, 'Guard hit you.', 'danger');
            }
          }
        },
        stepCameras(state) {
          for (const c of state.entities.cameras) {
            if (c.disabled > 0) { c.disabled -= 1; continue; }
            if (c.type === 'rotating') c.angle = (c.angle + 1) % 4;
          }
        }
      },

      rules: {
        canMove(state, x, y) {
          if (!state.utils.inBounds(state, x, y)) return false;
          const tile = state.tiles[state.utils.idx(state, x, y)];
          if (tile === 'wall') return false;
          if (tile === 'door') return false;
          return true;
        },
        playerAction(state, action) {
          if (action.type === 'move') {
            const tx = state.entities.player.x + action.dx;
            const ty = state.entities.player.y + action.dy;
            if (this.canMove(state, tx, ty)) {
              state.entities.player.x = tx;
              state.entities.player.y = ty;
              state.noise = Math.max(0, 2 - state.entities.player.emp);
            }
          }
          if (action.type === 'wait') state.noise = 0;
          if (action.type === 'emp' && state.entities.player.emp > 0) {
            state.entities.player.emp -= 1;
            for (const c of state.entities.cameras) {
              if (state.utils.manhattan(c, state.entities.player) <= 3) c.disabled = 4;
            }
            state.render.log(state, 'EMP pulse: cameras disabled for 4 turns.', 'warn');
          }
        },
        systemUpdate(state) {
          const p = state.entities.player;
          const i = state.utils.idx(state, p.x, p.y);
          const tile = state.tiles[i];

          for (const item of state.entities.items) {
            if (!item.used && item.x === p.x && item.y === p.y) {
              item.used = true;
              if (item.type === 'emp') {
                state.entities.player.emp += 2;
                state.render.log(state, 'Picked EMP charge (+2).');
              }
            }
          }

          if (state.floor < 5 && tile === 'exit') {
            state.floor += 1;
            state.render.log(state, `Floor ${state.floor} entered.`);
            startFloor(state);
            return true;
          }

          if (state.floor === 5 && tile === 'core' && state.downloadProgress < state.downloadNeeded) {
            state.downloadProgress += 1;
            state.render.log(state, `Core download ${state.downloadProgress}/${state.downloadNeeded}.`, 'warn');
          }

          if (state.floor === 5 && tile === 'extraction' && state.downloadProgress >= state.downloadNeeded) {
            state.mode = 'menu';
            state.dom.menu.style.display = 'grid';
            state.render.log(state, 'Run complete: Core exfiltration successful.', 'ok');
          }
          return false;
        },
        outcomeCheck(state) {
          if (state.hp <= 0 || state.exposure >= 3 || state.alertLevel >= 100) {
            state.mode = 'menu';
            state.dom.menu.style.display = 'grid';
            state.render.log(state, 'Mission failed: you were compromised.', 'danger');
          }
        },
        processTurn(state, action) {
          if (state.mode !== 'running') return;

          // A: Input -> action
          this.playerAction(state, action);
          // B: Action resolved above
          // C: System updates
          const changedFloor = this.systemUpdate(state);
          if (changedFloor) return;
          state.fov.recalc(state);
          state.detection.update(state);
          // D: Enemy turn
          state.ai.stepCameras(state);
          state.ai.stepGuards(state);
          // E: Outcome checks
          this.outcomeCheck(state);

          state.turn += 1;
          state.render.frame(state);
          state.storage.save(state);
        }
      },

      render: {
        createGridOnce(state) {
          if (state.cellEls.length) return;
          const frag = document.createDocumentFragment();
          for (let i = 0; i < state.width * state.height; i++) {
            const el = document.createElement('div');
            el.className = 'cell';
            el.textContent = ' ';
            state.cellEls.push(el);
            frag.appendChild(el);
          }
          state.dom.grid.appendChild(frag);
        },
        frame(state) {
          for (let y = 0; y < state.height; y++) {
            for (let x = 0; x < state.width; x++) {
              const i = state.utils.idx(state, x, y);
              const cell = state.cellEls[i];
              if (!state.memory[i]) {
                cell.className = 'cell';
                cell.style.opacity = 0.1;
                cell.textContent = ' ';
                continue;
              }
              const tile = state.tiles[i];
              cell.className = `cell tile-${tile}`;
              cell.style.opacity = state.visible[i] ? 1 : 0.38;
              cell.textContent = TILE_GLYPH[tile] || '?';
            }
          }

          const draw = (e, css, glyph = e.glyph) => {
            const i = state.utils.idx(state, e.x, e.y);
            if (!state.visible[i]) return;
            const cell = state.cellEls[i];
            cell.className = `cell ${css}`;
            cell.textContent = glyph;
          };

          draw(state.entities.player, 'tile-player');
          for (const g of state.entities.guards) draw(g, 'tile-enemy', 'G');
          for (const c of state.entities.cameras) draw(c, 'tile-enemy', c.disabled > 0 ? 'c' : 'C');
          for (const item of state.entities.items) if (!item.used) draw(item, 'tile-floor', item.glyph);

          const obj = LEVEL_OBJECTIVES[state.floor - 1];
          state.dom.objective.textContent = obj;
          state.dom.statusLeft.textContent = `HP:${state.hp} Noise:${state.noise} Turn:${state.turn} Exposure:${state.exposure} Alert:${state.alertLevel}`;
          state.dom.statusRight.textContent = `Mode:${state.mode} Floor:${state.floor}/5 Download:${state.downloadProgress}/${state.downloadNeeded}`;
          state.dom.seed.textContent = String(state.seed ?? '—');
          state.dom.daily.textContent = state.daily ? 'Yes' : 'No';
        },
        log(state, message, tone = 'ok') {
          const p = document.createElement('p');
          p.className = tone;
          p.textContent = `> ${message}`;
          state.dom.terminal.appendChild(p);
          state.dom.terminal.scrollTop = state.dom.terminal.scrollHeight;
        }
      },

      storage: {
        key: 'stealth-roguelite-save-v2',
        save(state) {
          const payload = {
            turn: state.turn, hp: state.hp, noise: state.noise, mode: state.mode, daily: state.daily, seed: state.seed,
            floor: state.floor, tiles: state.tiles, memory: state.memory, visible: state.visible, alertLevel: state.alertLevel,
            exposure: state.exposure, downloadProgress: state.downloadProgress, entities: state.entities
          };
          localStorage.setItem(this.key, JSON.stringify(payload));
        },
        load() {
          const raw = localStorage.getItem(this.key);
          return raw ? JSON.parse(raw) : null;
        }
      }
    };

    function startFloor(state) {
      for (let attempt = 0; attempt < 20; attempt++) {
        try {
          state.gen.map(state);
          state.gen.populate(state);
          state.fov.recalc(state);
          state.render.frame(state);
          state.storage.save(state);
          return;
        } catch (error) {
          state.render.log(state, `Regenerating floor: ${error.message}.`, 'warn');
        }
      }
      throw new Error('Unable to generate valid floor after retries');
    }

    function getLocalDateSeed() {
      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth() + 1).padStart(2, '0');
      const d = String(now.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    function initializeRun(type) {
      const today = getLocalDateSeed();
      const seed = type === 'daily' ? `daily-${today}` : `run-${Date.now()}-${Math.floor(Math.random() * 1e6)}`;
      gameState.random = gameState.rng.create(seed);
      gameState.turn = 1;
      gameState.mode = 'running';
      gameState.daily = type === 'daily';
      gameState.seed = seed;
      gameState.floor = 1;
      gameState.hp = 10;
      gameState.noise = 0;
      gameState.alertLevel = 0;
      gameState.exposure = 0;
      gameState.downloadProgress = 0;
      gameState.entities.player = { x: 1, y: 1, glyph: '@', emp: 0 };

      startFloor(gameState);
      gameState.render.log(gameState, `Run initialized with seed ${seed}`);
      gameState.dom.menu.style.display = 'none';
    }

    function continueRun() {
      const data = gameState.storage.load();
      if (!data) {
        gameState.render.log(gameState, 'No save found. Starting random run instead.', 'warn');
        initializeRun('random');
        return;
      }
      Object.assign(gameState, data);
      gameState.random = gameState.rng.create(gameState.seed || `restore-${Date.now()}`);
      gameState.mode = 'running';
      gameState.fov.recalc(gameState);
      gameState.render.frame(gameState);
      gameState.render.log(gameState, 'Continue successful. Save restored.');
      gameState.dom.menu.style.display = 'none';
    }

    gameState.render.createGridOnce(gameState);
    gameState.render.log(gameState, 'Boot sequence complete. Choose startup option.');


    gameState.dom.copySeed.addEventListener('click', async () => {
      if (!gameState.seed) {
        gameState.render.log(gameState, 'No active seed to copy.', 'warn');
        return;
      }
      try {
        await navigator.clipboard.writeText(String(gameState.seed));
        gameState.render.log(gameState, `Seed copied: ${gameState.seed}`);
      } catch {
        gameState.render.log(gameState, 'Clipboard unavailable in this environment.', 'warn');
      }
    });

    document.querySelector('.menu').addEventListener('click', (event) => {
      const btn = event.target.closest('button[data-action]');
      if (!btn) return;
      const action = btn.dataset.action;

      if (action === 'new-random') initializeRun('random');
      if (action === 'daily') initializeRun('daily');
      if (action === 'continue') continueRun();
      if (action === 'help') gameState.render.log(gameState, 'Arrows move, Space wait, E uses EMP near cameras.', 'warn');
      if (action === 'settings') gameState.render.log(gameState, 'Settings are not implemented in this prototype.', 'danger');
    });

    window.addEventListener('keydown', (event) => {
      if (gameState.mode !== 'running') return;
      const moves = { ArrowUp: [0, -1], ArrowDown: [0, 1], ArrowLeft: [-1, 0], ArrowRight: [1, 0] };
      let action = null;
      if (moves[event.key]) {
        const [dx, dy] = moves[event.key];
        action = { type: 'move', dx, dy };
      } else if (event.key === ' ' || event.key.toLowerCase() === 'z') {
        action = { type: 'wait' };
      } else if (event.key.toLowerCase() === 'e') {
        action = { type: 'emp' };
      }
      if (!action) return;
      event.preventDefault();
      gameState.rules.processTurn(gameState, action);
    });
  </script>

</body>
</html>
